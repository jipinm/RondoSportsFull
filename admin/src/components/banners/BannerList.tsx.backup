import React, { useState, useEffect } from 'react';
import type { Banner, BannersFilters } from '../../types/banners';
import { BannerCard } from './BannerCard';
import { BannerForm } from './BannerForm';
import { bannersService } from '../../services/bannersService';
import { useToast } from '../../hooks/useToast';
import ToastContainer from '../ToastContainer';
import styles from './BannerList.module.css';

interface BannerListProps {
  refreshTrigger?: number;
}

type BannerLocation = 'homepage_hero' | 'homepage_secondary' | 'category_page' | 'event_page';

const LOCATION_LABELS: Record<BannerLocation, string> = {
  homepage_hero: 'Homepage Hero Banners',
  homepage_secondary: 'Homepage Secondary Banners',
  category_page: 'Category Page Banners',
  event_page: 'Event Page Banners'
};

export const BannerList: React.FC<BannerListProps> = ({ refreshTrigger }) => {
  const [bannersByLocation, setBannersByLocation] = useState<Record<BannerLocation, Banner[]>>({
    homepage_hero: [],
    homepage_secondary: [],
    category_page: [],
    event_page: []
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string>('');
  const [searchInput, setSearchInput] = useState<string>('');
  const [showForm, setShowForm] = useState(false);
  const [editingBanner, setEditingBanner] = useState<Banner | undefined>();
  const [formLoading, setFormLoading] = useState(false);
  
  // Toast notifications
  const toast = useToast();
  
  // Drag and drop state - per location
  const [draggedBanner, setDraggedBanner] = useState<{ banner: Banner; location: BannerLocation } | null>(null);
  const [savingPositions, setSavingPositions] = useState<BannerLocation | null>(null);

  const loadBanners = async () => {
    try {
      setLoading(true);
      setError('');

      // Load all banners without pagination
      const response = await bannersService.getBanners({}, 1, 1000);
      
      // Group banners by location
      const grouped: Record<BannerLocation, Banner[]> = {
        homepage_hero: [],
        homepage_secondary: [],
        category_page: [],
        event_page: []
      };

      response.data.forEach(banner => {
        const location = banner.location as BannerLocation;
        if (grouped[location]) {
          grouped[location].push(banner);
        }
      });

      // Sort each group by position_order
      Object.keys(grouped).forEach(location => {
        grouped[location as BannerLocation].sort((a, b) => a.position_order - b.position_order);
      });

      setBannersByLocation(grouped);
    } catch (err: any) {
      setError(err.message || 'Failed to load banners');
      console.error('Error loading banners:', err);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadBanners();
  }, [refreshTrigger]);

  const handleFilterChange = (field: keyof BannersFilters, value: string) => {
    const newFilters = { ...filters, [field]: value || undefined };
    setFilters(newFilters);
    loadBanners(1, newFilters);
  };

  const handleSearch = () => {
    const newFilters = { ...filters, search: searchInput || undefined };
    setFilters(newFilters);
    loadBanners(1, newFilters);
  };

  const handleSearchKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      handleSearch();
    }
  };

  const handlePageChange = (page: number) => {
    loadBanners(page);
  };

  const handleCreateBanner = () => {
    setEditingBanner(undefined);
    setShowForm(true);
  };

  const handleEditBanner = (banner: Banner) => {
    setEditingBanner(banner);
    setShowForm(true);
  };

  const handleDeleteBanner = async (id: number) => {
    if (!confirm('Are you sure you want to delete this banner?')) {
      return;
    }

    try {
      await bannersService.deleteBanner(id);
      toast.success('Banner deleted successfully');
      await loadBanners(pagination.current_page);
    } catch (err: any) {
      toast.error('Failed to delete banner', err.message || 'An unexpected error occurred');
    }
  };

  const handleToggleStatus = async (id: number) => {
    try {
      const banner = banners.find(b => b.id === id);
      if (!banner) return;

      const newStatus = banner.status === 'active' ? 'inactive' : 'active';
      await bannersService.updateBanner(id, { status: newStatus });
      toast.success(`Banner ${newStatus === 'active' ? 'activated' : 'deactivated'} successfully`);
      await loadBanners(pagination.current_page);
    } catch (err: any) {
      toast.error('Failed to update banner status', err.message || 'An unexpected error occurred');
    }
  };

  const handleFormSubmit = async (data: any) => {
    try {
      setFormLoading(true);

      if (editingBanner) {
        await bannersService.updateBanner(editingBanner.id, data);
        toast.success('Banner updated successfully');
      } else {
        await bannersService.createBanner(data);
        toast.success('Banner created successfully');
      }

      setShowForm(false);
      setEditingBanner(undefined);
      await loadBanners(pagination.current_page);
    } catch (err: any) {
      const errorMessage = err.message || 'Failed to save banner';
      toast.error('Failed to save banner', errorMessage);
      throw new Error(errorMessage);
    } finally {
      setFormLoading(false);
    }
  };

  const handleFormCancel = () => {
    setShowForm(false);
    setEditingBanner(undefined);
  };

  // Drag and drop handlers
  const handleDragStart = (e: React.DragEvent, banner: Banner) => {
    setDraggedBanner(banner);
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', banner.id.toString());
    // Add a slight delay to show dragging state
    setTimeout(() => {
      const element = e.target as HTMLElement;
      element.style.opacity = '0.5';
    }, 0);
  };

  const handleDragEnd = (e: React.DragEvent) => {
    setDraggedBanner(null);
    const element = e.target as HTMLElement;
    element.style.opacity = '1';
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  };

  const handleDrop = async (e: React.DragEvent, targetBanner: Banner) => {
    e.preventDefault();
    
    if (!draggedBanner || draggedBanner.id === targetBanner.id) {
      setDraggedBanner(null);
      return;
    }

    // Reorder banners locally
    const newBanners = [...banners];
    const draggedIndex = newBanners.findIndex(b => b.id === draggedBanner.id);
    const targetIndex = newBanners.findIndex(b => b.id === targetBanner.id);

    if (draggedIndex === -1 || targetIndex === -1) {
      setDraggedBanner(null);
      return;
    }

    // Remove dragged item and insert at target position
    const [removed] = newBanners.splice(draggedIndex, 1);
    newBanners.splice(targetIndex, 0, removed);

    // Update position_order for all banners
    const updatedBanners = newBanners.map((banner, index) => ({
      ...banner,
      position_order: index + 1
    }));

    setBanners(updatedBanners);
    setDraggedBanner(null);

    // Save positions to API
    try {
      setSavingPositions(true);
      const positions: Record<number, number> = {};
      updatedBanners.forEach(banner => {
        positions[banner.id] = banner.position_order;
      });
      await bannersService.updateBannerPositions(positions);
    } catch (err: any) {
      alert(err.message || 'Failed to save banner positions');
      // Reload banners to get correct order
      await loadBanners(pagination.current_page);
    } finally {
      setSavingPositions(false);
    }
  };

  const clearFilters = () => {
    setFilters({});
    setSearchInput('');
    loadBanners(1, {});
  };

  const renderPagination = () => {
    if (pagination.total_pages <= 1) return null;

    const pages = [];
    const currentPage = pagination.current_page;
    const totalPages = pagination.total_pages;

    // Previous button
    pages.push(
      <button
        key="prev"
        onClick={() => handlePageChange(currentPage - 1)}
        disabled={currentPage === 1}
        className={`${styles.pageButton} ${currentPage === 1 ? styles.disabled : ''}`}
      >
        ‚Äπ Previous
      </button>
    );

    // Page numbers
    for (let i = Math.max(1, currentPage - 2); i <= Math.min(totalPages, currentPage + 2); i++) {
      pages.push(
        <button
          key={i}
          onClick={() => handlePageChange(i)}
          className={`${styles.pageButton} ${i === currentPage ? styles.active : ''}`}
        >
          {i}
        </button>
      );
    }

    // Next button
    pages.push(
      <button
        key="next"
        onClick={() => handlePageChange(currentPage + 1)}
        disabled={currentPage === totalPages}
        className={`${styles.pageButton} ${currentPage === totalPages ? styles.disabled : ''}`}
      >
        Next ‚Ä∫
      </button>
    );

    return (
      <div className={styles.pagination}>
        {pages}
      </div>
    );
  };

  return (
    <div className={styles.bannerList}>
      <div className={styles.header}>
        <div className={styles.headerContent}>
          <h2 className={styles.title}>Banner Management</h2>
          <button
            onClick={handleCreateBanner}
            className={styles.createButton}
          >
            ‚ûï Create Banner
          </button>
        </div>

        <div className={styles.filters}>
          <div className={styles.filterGroup}>
            <div className={styles.searchContainer}>
              <input
                type="text"
                placeholder="Search banners..."
                value={searchInput}
                onChange={(e) => setSearchInput(e.target.value)}
                onKeyPress={handleSearchKeyPress}
                className={styles.searchInput}
              />
              <button
                onClick={handleSearch}
                className={styles.searchButton}
                title="Search"
              >
                üîç
              </button>
            </div>
          </div>

          <div className={styles.filterGroup}>
            <select
              value={filters.status || ''}
              onChange={(e) => handleFilterChange('status', e.target.value)}
              className={styles.filterSelect}
            >
              <option value="">All Statuses</option>
              <option value="active">Active</option>
              <option value="inactive">Inactive</option>
              <option value="scheduled">Scheduled</option>
            </select>
          </div>

          <div className={styles.filterGroup}>
            <select
              value={filters.location || ''}
              onChange={(e) => handleFilterChange('location', e.target.value)}
              className={styles.filterSelect}
            >
              <option value="">All Locations</option>
              <option value="homepage_hero">Homepage Hero</option>
              <option value="homepage_secondary">Homepage Secondary</option>
              <option value="category_page">Category Page</option>
              <option value="event_page">Event Page</option>
            </select>
          </div>

          {(filters.search || filters.status || filters.location) && (
            <button
              onClick={clearFilters}
              className={styles.clearFiltersButton}
            >
              Clear Filters
            </button>
          )}
        </div>
      </div>

      {error && (
        <div className={styles.errorMessage}>
          <span>‚ùå {error}</span>
          <button onClick={() => loadBanners()} className={styles.retryButton}>
            Retry
          </button>
        </div>
      )}

      {loading ? (
        <div className={styles.loading}>
          <div className={styles.spinner}></div>
          <span>Loading banners...</span>
        </div>
      ) : (
        <>
          {banners.length === 0 ? (
            <div className={styles.emptyState}>
              <div className={styles.emptyIcon}>üìÑ</div>
              <h3>No banners found</h3>
              <p>
                {Object.keys(filters).some(key => filters[key as keyof BannersFilters])
                  ? 'No banners match your current filters.'
                  : 'Get started by creating your first banner.'}
              </p>
              {!Object.keys(filters).some(key => filters[key as keyof BannersFilters]) && (
                <button onClick={handleCreateBanner} className={styles.emptyCreateButton}>
                  Create Your First Banner
                </button>
              )}
            </div>
          ) : (
            <>
              {savingPositions && (
                <div className={styles.savingIndicator}>
                  Saving positions...
                </div>
              )}
              <div className={styles.sortInfo}>
                <span>üí° Drag and drop banners to reorder them</span>
              </div>
              <div className={styles.bannerGrid}>
                {banners.map((banner) => (
                  <BannerCard
                    key={banner.id}
                    banner={banner}
                    onEdit={handleEditBanner}
                    onDelete={handleDeleteBanner}
                    onToggleStatus={handleToggleStatus}
                    isDragging={draggedBanner?.id === banner.id}
                    onDragStart={handleDragStart}
                    onDragEnd={handleDragEnd}
                    onDragOver={handleDragOver}
                    onDrop={handleDrop}
                  />
                ))}
              </div>
              
              {renderPagination()}
              
              <div className={styles.results}>
                Showing {(pagination.current_page - 1) * pagination.per_page + 1} to{' '}
                {Math.min(pagination.current_page * pagination.per_page, pagination.total)} of{' '}
                {pagination.total} banners
              </div>
            </>
          )}
        </>
      )}

      {showForm && (
        <BannerForm
          banner={editingBanner}
          onSubmit={handleFormSubmit}
          onCancel={handleFormCancel}
          isLoading={formLoading}
        />
      )}
      
      <ToastContainer toasts={toast.toasts} onClose={toast.closeToast} />
    </div>
  );
};